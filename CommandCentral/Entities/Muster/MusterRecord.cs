using System;
using System.Collections.Generic;
using CommandCentral.ClientAccess;
using FluentNHibernate.Mapping;
using AtwoodUtils;
using System.Linq;
using NHibernate.Criterion;
using CommandCentral.Authorization;

namespace CommandCentral.Entities.Muster
{
    /// <summary>
    /// Describes a single muster record, intended to archive the fact that a person claimed that another person was in a given state at a given time.
    /// </summary>
    public class MusterRecord
    {

        /// <summary>
        /// The hour at which the muster will roll over, starting a new muster day, regardless of the current muster's status.
        /// </summary>
        private static readonly Time _rolloverTime = new Time(16, 0, 0);

        /// <summary>
        /// The hour at which the muster _should_ be completed.  This governs when email are sent and their urgency.
        /// </summary>
        private static readonly Time _dueTime = new Time(9, 30, 0);

        /// <summary>
        /// Tracks whether or not the muster has been finalized.  If it has been, no more muster records should be accepted.
        /// <para />
        /// This is used in situations where a client forces the muster to finalize prior to its rollover time.
        /// </summary>
        public static bool IsMusterFinalized { get; private set; }

        #region Properties

        /// <summary>
        /// Unique GUID of this muster record
        /// </summary>
        public virtual Guid Id { get; set; }

        /// <summary>
        /// Musterer - I hate that word
        /// </summary>
        public virtual Person Musterer { get; set; }

        /// <summary>
        /// The Person being mustered by the musterer, which is the person mustering the person that must be mustered. muster.
        /// </summary>
        public virtual Person Musteree { get; set; }

        /// <summary>
        /// The Person being mustered's paygrade. Fucking Mustard.
        /// </summary>
        public virtual string Paygrade { get; set; }

        /// <summary>
        /// The person being mustered's UIC.  Fucking Mustard x 2.
        /// </summary>
        public virtual string UIC { get; set; }

        /// <summary>
        /// The person that is having the muster happen to them's division.
        /// </summary>
        public virtual string Division { get; set; }

        /// <summary>
        /// The individual that is being made accountable for through the process of mustering's department
        /// </summary>
        public virtual string Department { get; set; }

        /// <summary>
        /// The human being chosen to say their name out loud in front of their peers to make sure they are alive and where they should be at that specific time's Command
        /// </summary>
        public virtual string Command { get; set; }

        /// <summary>
        /// The one tiny human being on this planet out of all the other people that signed a contract that has binded him into a life of accountability's muster state.
        /// </summary>
        public virtual string MusterStatus { get; set; }

        /// <summary>
        /// That same person from above's duty status
        /// </summary>
        public virtual string DutyStatus { get; set; }

        /// <summary>
        /// The date and time the person was mustered at.
        /// </summary>
        public virtual DateTime SubmitTime { get; set; }

        /// <summary>
        /// The day of the year for which this muster was made.  Because the "muster day" may not align perfectly with a normal day, this value is tracked separately.
        /// </summary>
        public virtual int MusterDayOfYear { get; set; }

        /// <summary>
        /// The year this muster record is in.
        /// </summary>
        public virtual int MusterYear { get; set; }

        /// <summary>
        /// Indicates whether or not this record has been submitted yet or if it was auto generated by the application.
        /// </summary>
        public virtual bool HasBeenSubmitted { get; set; }

        #endregion

        #region Helper Methods

        /// <summary>
        /// Returns the muster day, which is the Julian date shifted by the offset given by the _rolloverHour variable.
        /// </summary>
        /// <param name="dateTime"></param>
        /// <returns></returns>
        public static int GetMusterDay(DateTime dateTime)
        {
            System.Globalization.JulianCalendar julCalendar = new System.Globalization.JulianCalendar();

            if (dateTime.InclusiveBetween(dateTime.Date.Subtract(TimeSpan.FromHours(24) - TimeSpan.FromSeconds(_rolloverTime.GetSeconds())), dateTime.Date.AddSeconds(_rolloverTime.GetSeconds())))
                return julCalendar.GetDayOfYear(dateTime);
            else
            {
                //If we're here then we're after the muster rollover hour.  For example, the roll over is 16 and we're on 17.  This means that the muster day is the NEXT day.
                //However, we need to make sure we don't return a date that is out of range for the year.  So if today is the last day of the year, then return 1, because we'll be starting next year's muster.
                if (julCalendar.GetDaysInYear(dateTime.Year) == julCalendar.GetDayOfYear(dateTime))
                    return 1;
                else
                    return julCalendar.GetDayOfYear(dateTime) + 1;
            }
        }

        /// <summary>
        /// Gets the current year of the muster.
        /// </summary>
        /// <param name="dateTime"></param>
        /// <returns></returns>
        public static int GetMusterYear(DateTime dateTime)
        {
            System.Globalization.JulianCalendar julCalendar = new System.Globalization.JulianCalendar();

            if (dateTime.InclusiveBetween(dateTime.Date.Subtract(TimeSpan.FromHours(24) - TimeSpan.FromSeconds(_rolloverTime.GetSeconds())), dateTime.Date.AddSeconds(_rolloverTime.GetSeconds())))
                return julCalendar.GetYear(dateTime);
            else
            {
                //If we're here then we're after the muster rollover hour.  For example, the roll over is 16 and we're on 17.  This means that the muster day is the NEXT day.
                //However, we need to make sure we don't return a date that is out of range for the year.  So if today is the last day of the year, then return 1, because we'll be starting next year's muster.
                if (julCalendar.GetDaysInYear(dateTime.Year) == julCalendar.GetDayOfYear(dateTime))
                    return julCalendar.GetYear(dateTime) + 1; //This makes the assumption that time is infinite.  This might require refactoring if proven otherwise.
                else
                    return julCalendar.GetYear(dateTime);
            }
        }

        /// <summary>
        /// Creates a new muster status with everything set to null except the musteree and the current day values.
        /// </summary>
        /// <param name="person"></param>
        /// <param name="date">The date time for which to create this muster record.</param>
        /// <returns></returns>
        public static MusterRecord CreateDefaultMusterRecordForPerson(Person person, DateTime date)
        {
            return new MusterRecord
            {
                Id = Guid.NewGuid(),
                Command = null,
                Department = null,
                Division = null,
                DutyStatus = null,
                MusterDayOfYear = GetMusterDay(date),
                Musteree = person,
                Musterer = null,
                MusterStatus = null,
                MusterYear = GetMusterYear(date),
                Paygrade = null,
                UIC = null,
                SubmitTime = default(DateTime)
            };
        }

        /// <summary>
        /// Returns a boolean indicating whether or not the given person (client) can muster the other given person (person).
        /// </summary>
        /// <param name="client"></param>
        /// <param name="person"></param>
        /// <returns></returns>
        public static bool CanClientMusterPerson(Person client, Person person)
        {
            //TODO: rewrite the chain of command check here.

            return true;
        }

        /// <summary>
        /// Finalizes the muster for the current day by taking all of the current muster records from all persons in the database, 
        /// using them to build a report, 
        /// sending an email report, 
        /// saving the report,
        /// and then resetting everyone's current muster record and then archiving the old ones.
        /// </summary>
        /// <param name="person">The person who initiated the muster finalization.  If null, the system initiated it.</param>
        public static void FinalizeMuster(Person person)
        {
            if (IsMusterFinalized)
                throw new Exception("You can't finalize the muster.  It's already been finalized.  A rollover must first occur.");

            //First up, we need everyone and their muster records.  Actually we need a session first.
            using (var session = DataAccess.NHibernateHelper.CreateStatefulSession())
            using (var transaction = session.BeginTransaction())
            {
                try
                {
                    //Set it to true to prevent anyone else trying to finalize the muster while we're processing.
                    IsMusterFinalized = true;

                    var persons = GetMusterablePersons(session);
                    
                    //Ok we have all the persons and their muster records.  #thatwaseasy  Now we need to build a report of the current muster
                    foreach (Person per in persons)
                    {
                        per.CurrentMusterStatus.Command = per.Command.Value;
                        per.CurrentMusterStatus.Department = per.Department.Value;
                        per.CurrentMusterStatus.Division = per.Division.Value;
                        per.CurrentMusterStatus.DutyStatus = per.DutyStatus.ToString();
                        if (!per.CurrentMusterStatus.HasBeenSubmitted)
                        {
                            per.CurrentMusterStatus.MusterStatus = CommandCentral.MusterStatuses.UA.ToString();
                            per.CurrentMusterStatus.SubmitTime = DateTime.Now;
                        }
                        per.CurrentMusterStatus.HasBeenSubmitted = true;
                        per.CurrentMusterStatus.Paygrade = per.Paygrade.ToString();
                        per.CurrentMusterStatus.UIC = per.UIC == null ? "" : per.UIC.Value;

                        session.Save(per);
                    }

                    transaction.Commit();
                }
                catch (Exception e)
                {
                    transaction.Rollback();

                    //Set to false becaues we rolled back our changes.
                    IsMusterFinalized = false;

                    Communicator.PostMessage("The finalize muster method failed!  All changes were rolled back. The muster was not finalized! Error message: {0}".FormatS(e.Message), Communicator.MessageTypes.Critical);

                    EmailHelper.SendFatalErrorEmail(null, e);

                    session.Save(new Error(e, DateTime.Now, null));

                    //Note: we can't rethrow the error because no one is listening for it.  We just need to handle that here.  We're far outside the sync context, just south of the rishi maze.
                }
            }
        }

        /// <summary>
        /// Rolls over the muster.
        /// </summary>
        public static void RolloverMuster()
        {
            if (!IsMusterFinalized)
                throw new Exception("You can't rollover the muster until it has been finalized.");

            //First up, we need everyone and their muster records.  Actually we need a session first.
            using (var session = DataAccess.NHibernateHelper.CreateStatefulSession())
            using (var transaction = session.BeginTransaction())
            {
                try
                {
                    var persons = GetMusterablePersons(session);

                    //Now we need to go through each person and reset their current muster status.
                    foreach (var person in persons)
                    {
                        person.CurrentMusterStatus = CreateDefaultMusterRecordForPerson(person, DateTime.Now);
                        session.Save(person);
                    }

                    IsMusterFinalized = false;

                    transaction.Commit();
                }
                catch (Exception e)
                {
                    transaction.Rollback();

                    Communicator.PostMessage("The rollover muster method failed!  All changes were rolled back. The muster was not advanced! Error message: {0}".FormatS(e.Message), Communicator.MessageTypes.Critical);

                    EmailHelper.SendFatalErrorEmail(null, e);

                    session.Save(new Error(e, DateTime.Now, null));

                    //Note: we can't rethrow the error because no one is listening for it.  We just need to handle that here.  We're far outside the sync context, just south of the rishi maze.
                }
            }
        }

        /// <summary>
        /// Returns a list of those persons who are currently musterable.  Uses a given session to do the loading.
        /// </summary>
        /// <param name="session"></param>
        /// <returns></returns>
        public static IList<Person> GetMusterablePersons(NHibernate.ISession session)
        {
            return session.QueryOver<Person>().Where(x => x.DutyStatus != DutyStatuses.Loss).List();
        }

        /// <summary>
        /// Returns a list of those persons who are currently musterable.  Uses a new session to do the loading then disposes it.
        /// </summary>
        /// <param name="session"></param>
        /// <returns></returns>
        public static IList<Person> GetMusterablePersons()
        {

            using (var session = DataAccess.NHibernateHelper.CreateStatefulSession())
            {
                return session.QueryOver<Person>().Where(x => x.DutyStatus != DutyStatuses.Loss).List();
            }
        }

        #endregion

        #region Client Access

        /// <summary>
        /// WARNING!  THIS METHOD IS EXPOSED TO THE CLIENT AND IS NOT INTENDED FOR INTERNAL USE.  AUTHENTICATION, AUTHORIZATION AND VALIDATION MUST BE HANDLED PRIOR TO DB INTERACTION.
        /// <para />
        /// Loads a muster record for a given id and returns null if none exists.
        /// <para />
        /// Client Parameters: <para />
        ///     musterrecordid - the Id of the muster record we want to load.
        /// </summary>
        /// <param name="token"></param>
        /// <returns></returns>
        [EndpointMethod(EndpointName = "LoadMusterRecord", AllowArgumentLogging = true, AllowResponseLogging = true, RequiresAuthentication = true)]
        private static void EndpointMethod_LoadMusterRecord(MessageToken token)
        {
            if (token.AuthenticationSession == null)
            {
                token.AddErrorMessage("You must be logged in to view muster records.", ErrorTypes.Authentication, System.Net.HttpStatusCode.Unauthorized);
                return;
            }

            if (!token.Args.ContainsKey("musterrecordid"))
            {
                token.AddErrorMessage("You must send a 'musterrecordid' parameter.", ErrorTypes.Validation, System.Net.HttpStatusCode.BadRequest);
                return;
            }

            Guid musterRecordId;
            if (!Guid.TryParse(token.Args["musterrecordid"] as string, out musterRecordId))
            {
                token.AddErrorMessage("Your muster record id was not legitsky.", ErrorTypes.Validation, System.Net.HttpStatusCode.BadRequest);
                return;
            }

            using (var session = DataAccess.NHibernateHelper.CreateStatefulSession())
            {
                var musterRecord = session.Get<MusterRecord>(musterRecordId);

                if (musterRecord == null)
                {
                    token.SetResult(null);
                    return;
                }

                //Create a DTO for the client.
                token.SetResult(new
                    {
                        musterRecord.Command,
                        musterRecord.Department,
                        musterRecord.Division,
                        musterRecord.DutyStatus,
                        musterRecord.HasBeenSubmitted,
                        musterRecord.Id,
                        musterRecord.MusterDayOfYear,
                        Musteree = musterRecord.Musteree.ToBasicPerson(),
                        Musterer = musterRecord.Musterer.ToBasicPerson(),
                        musterRecord.MusterStatus,
                        musterRecord.MusterYear,
                        musterRecord.Paygrade,
                        musterRecord.SubmitTime,
                        musterRecord.UIC
                    });
            }
        }

        /// <summary>
        /// WARNING!  THIS METHOD IS EXPOSED TO THE CLIENT AND IS NOT INTENDED FOR INTERNAL USE.  AUTHENTICATION, AUTHORIZATION AND VALIDATION MUST BE HANDLED PRIOR TO DB INTERACTION.
        /// <para />
        /// Loads all muster records for a given person in which the person was the Musteree - the one being le mustered.  
        /// <para />
        /// Client Parameters: <para />
        ///     mustereeId - the Id of the person for whom to load muster records where the person is the one being mustered.
        /// </summary>
        /// <param name="token"></param>
        /// <returns></returns>
        [EndpointMethod(EndpointName = "LoadMusterRecordsByMusteree", AllowArgumentLogging = true, AllowResponseLogging = true, RequiresAuthentication = true)]
        private static void EndpointMethod_LoadMusterRecordsByMusteree(MessageToken token)
        {
            if (token.AuthenticationSession == null)
            {
                token.AddErrorMessage("You must be logged in to view muster records.", ErrorTypes.Authentication, System.Net.HttpStatusCode.Unauthorized);
                return;
            }

            if (!token.Args.ContainsKey("mustereeid"))
            {
                token.AddErrorMessage("You must send a 'mustereeid' parameter.", ErrorTypes.Validation, System.Net.HttpStatusCode.BadRequest);
                return;
            }

            Guid mustereeId;
            if (!Guid.TryParse(token.Args["mustereeid"] as string, out mustereeId))
            {
                token.AddErrorMessage("Your 'mustereeid' parameter was not in a valid format.", ErrorTypes.Validation, System.Net.HttpStatusCode.BadRequest);
                return;
            }

            using (var session = DataAccess.NHibernateHelper.CreateStatefulSession())
            {
                //Set the result.
                token.SetResult(session.QueryOver<MusterRecord>().Where(x => x.Musteree.Id == mustereeId).List().Select(x => new
                    {
                        x.Command,
                        x.Department,
                        x.Division,
                        x.DutyStatus,
                        x.HasBeenSubmitted,
                        x.Id,
                        x.MusterDayOfYear,
                        Musteree = x.Musteree.ToBasicPerson(),
                        Musterer = x.Musterer.ToBasicPerson(),
                        x.MusterStatus,
                        x.MusterYear,
                        x.Paygrade,
                        x.SubmitTime,
                        x.UIC
                    }));
            }
        }

        /// <summary>
        /// WARNING!  THIS METHOD IS EXPOSED TO THE CLIENT AND IS NOT INTENDED FOR INTERNAL USE.  AUTHENTICATION, AUTHORIZATION AND VALIDATION MUST BE HANDLED PRIOR TO DB INTERACTION.
        /// <para />
        /// Loads all muster records for a given person in which the person was the Musterer - the one doing le mustering.  
        /// <para />
        /// Client Parameters: <para />
        ///     mustererId - the Id of the person for whom to load muster records where the person is the one doing the mustering.
        /// </summary>
        /// <param name="token"></param>
        /// <returns></returns>
        [EndpointMethod(EndpointName = "LoadMusterRecordsByMusterer", AllowArgumentLogging = true, AllowResponseLogging = true, RequiresAuthentication = true)]
        private static void EndpointMethod_LoadMusterRecordsByMusterer(MessageToken token)
        {
            if (token.AuthenticationSession == null)
            {
                token.AddErrorMessage("You must be logged in to view muster records.", ErrorTypes.Authentication, System.Net.HttpStatusCode.Unauthorized);
                return;
            }

            if (!token.Args.ContainsKey("mustererid"))
            {
                token.AddErrorMessage("You must send a 'mustererid' parameter.", ErrorTypes.Validation, System.Net.HttpStatusCode.BadRequest);
                return;
            }

            Guid mustererId;
            if (!Guid.TryParse(token.Args["mustererid"] as string, out mustererId))
            {
                token.AddErrorMessage("Your 'mustererid' parameter was not in a valid format.", ErrorTypes.Validation, System.Net.HttpStatusCode.BadRequest);
                return;
            }

            using (var session = DataAccess.NHibernateHelper.CreateStatefulSession())
            {
                //Set the result.
                token.SetResult(session.QueryOver<MusterRecord>().Where(x => x.Musterer.Id == mustererId).List().Select(x => new
                {
                    x.Command,
                    x.Department,
                    x.Division,
                    x.DutyStatus,
                    x.HasBeenSubmitted,
                    x.Id,
                    x.MusterDayOfYear,
                    Musteree = x.Musteree.ToBasicPerson(),
                    Musterer = x.Musterer.ToBasicPerson(),
                    x.MusterStatus,
                    x.MusterYear,
                    x.Paygrade,
                    x.SubmitTime,
                    x.UIC
                }));
            }
        }

        /// <summary>
        /// WARNING!  THIS METHOD IS EXPOSED TO THE CLIENT AND IS NOT INTENDED FOR INTERNAL USE.  AUTHENTICATION, AUTHORIZATION AND VALIDATION MUST BE HANDLED PRIOR TO DB INTERACTION.
        /// <para />
        /// Loads all muster records for a given muster date. This will be converted to a muster date based on the rollover time shift.  Recommend that you submit the date time without a time portion or with the time portion set to midnight - although it doesn't matter.
        /// <para />
        /// Client Parameters: <para />
        ///     musterdate - The date for which to load muster records. Keep in mind, asking for muster records for a time after the roll over time will in fact return the next day's muster records.  This is due to the rollover time shift.
        /// </summary>
        /// <param name="token"></param>
        /// <returns></returns>
        [EndpointMethod(EndpointName = "LoadMusterRecordsByMusterDay", AllowArgumentLogging = true, AllowResponseLogging = true, RequiresAuthentication = true)]
        private static void EndpointMethod_LoadMusterRecordsByMusterDay(MessageToken token)
        {
            if (token.AuthenticationSession == null)
            {
                token.AddErrorMessage("You must be logged in to view muster records.", ErrorTypes.Authentication, System.Net.HttpStatusCode.Unauthorized);
                return;
            }

            if (!token.Args.ContainsKey("musterdate"))
            {
                token.AddErrorMessage("You must send a 'musterdate' parameter.", ErrorTypes.Validation, System.Net.HttpStatusCode.BadRequest);
                return;
            }

            DateTime musterDate;
            if (!(token.Args["musterdate"] is DateTime))
            {
                token.AddErrorMessage("Your 'musterdate' parameter was not in a valid format.", ErrorTypes.Validation, System.Net.HttpStatusCode.BadRequest);
                return;
            }
            else
            {
                //Here we set the date time to .Date.  This strips off the time component.
                musterDate = ((DateTime)token.Args["musterdate"]).Date;
            }

            using (var session = DataAccess.NHibernateHelper.CreateStatefulSession())
            {
                //Get all records where the day of the year is the given day's muster day and the year the same.
                var records = session.QueryOver<MusterRecord>().Where(x => x.MusterDayOfYear == MusterRecord.GetMusterDay(musterDate) && x.MusterYear == musterDate.Year).List();
                token.SetResult(records.Select(x => new
                {
                    x.Command,
                    x.Department,
                    x.Division,
                    x.DutyStatus,
                    x.HasBeenSubmitted,
                    x.Id,
                    x.MusterDayOfYear,
                    Musteree = x.Musteree.ToBasicPerson(),
                    Musterer = x.Musterer == null ? null : x.Musterer.ToBasicPerson(),
                    x.MusterStatus,
                    x.MusterYear,
                    x.Paygrade,
                    x.SubmitTime,
                    x.UIC
                }));
            }
        }

        /// <summary>
        /// WARNING!  THIS METHOD IS EXPOSED TO THE CLIENT AND IS NOT INTENDED FOR INTERNAL USE.  AUTHENTICATION, AUTHORIZATION AND VALIDATION MUST BE HANDLED PRIOR TO DB INTERACTION.
        /// <para />
        /// Given a dictionary of personIds/MusterStatuses, attempts to submit muster for all persons, failing if a person doesn't exist for the given Id, or if the client can't submit muster for any one of the persons.  If a person has already been mustered for this day, that person is not re-mustered.  All persons who were mustered, their Ids will be returned.
        /// <para />
        /// Options: <para />
        ///     mustersubmissions - A dictionary where the key is the person's Id, and the value is the MusterStatus to assign to this person.  The muster status should be a full muster status object.
        /// </summary>
        /// <param name="token"></param>
        /// <returns></returns>
        [EndpointMethod(EndpointName = "SubmitMuster", AllowArgumentLogging = true, AllowResponseLogging = true, RequiresAuthentication = true)]
        private static void EndpointMethod_SubmitMuster(MessageToken token)
        {
            if (token.AuthenticationSession == null)
            {
                token.AddErrorMessage("You must be logged in to submit muster records.", ErrorTypes.Authentication, System.Net.HttpStatusCode.Unauthorized);
                return;
            }

            //Did we get what we needed?
            if (!token.Args.ContainsKey("mustersubmissions"))
            {
                token.AddErrorMessage("You must send a 'mustersubmissions' parameter.", ErrorTypes.Validation, System.Net.HttpStatusCode.BadRequest);
                return;
            }


            Dictionary<Guid, string> musterSubmissions = null;
            //When we try to parse the JSON from the request, we'll do it in a try catch because there's no convenient, performant TryParse implementation for this.
            try
            {
                musterSubmissions = token.Args["mustersubmissions"].CastJToken<Dictionary<Guid, string>>();
            }
            catch (Exception e)
            {
                token.AddErrorMessage("There was an error while trying to format your 'mustersubmissions' argument.  It should be sent in a JSON dictionary.  Parsing error details: {0}".FormatS(e.Message), ErrorTypes.Validation, System.Net.HttpStatusCode.BadRequest);
                return;
            }

            //Validate the muster statuses
            MusterStatuses tempStatus;
            if (musterSubmissions.Values.Any(x => !Enum.TryParse<MusterStatuses>(x, out tempStatus)))
            {
                token.AddErrorMessage("One or more requested muster statuses were not valid.", ErrorTypes.Validation, System.Net.HttpStatusCode.BadRequest);
                return;
            }

            //This is the session in which we're going to do our muster updates.  We do it separately in case something terrible happens to the currently logged in user.
            //This means that if the currently logged in person updates their own muster then for the rest of this request, their muster will be invalid.  That's ok cause we shouldn't need it.
            using (var session = DataAccess.NHibernateHelper.CreateStatefulSession())
            using (var transaction = session.BeginTransaction())
            {
                //Tell the session we'll handle commits through the transaction, otherwise every property update on the current muster status will result in an update.
                session.CacheMode = NHibernate.CacheMode.Ignore;
                session.FlushMode = NHibernate.FlushMode.Commit;

                //Submit the query to load all the persons.  How fucking easy can this be.  Fuck off NHibernate.  Fetch the command/dep/div so we can use it without lazy loading.
                var persons = session.QueryOver<Person>().AndRestrictionOn(x => x.Id).IsIn(musterSubmissions.Keys).List();

                //Now we need to make sure the client is allowed to muster the persons the client wants to muster.
                if (persons.Any(x => !CanClientMusterPerson(token.AuthenticationSession.Person, x)))
                {
                    token.AddErrorMessage("You were not authorized to muster one or more of the persons you tried to muster.", ErrorTypes.Authorization, System.Net.HttpStatusCode.Unauthorized);
                    return;
                }

                //Ok, the client is allowed to muster them.  Now we need to set their current muster statuses.
                for (int x = 0; x < persons.Count; x++)
                {
                    persons[x].CurrentMusterStatus.HasBeenSubmitted = true;
                    persons[x].CurrentMusterStatus.MusterDayOfYear = GetMusterDay(token.CallTime);
                    persons[x].CurrentMusterStatus.Musterer = token.AuthenticationSession.Person;
                    persons[x].CurrentMusterStatus.MusterStatus = musterSubmissions.ElementAt(x).Value;
                    persons[x].CurrentMusterStatus.MusterYear = GetMusterYear(token.CallTime);
                    persons[x].CurrentMusterStatus.SubmitTime = token.CallTime;

                    //And once we're done resetting their current muster status, let's update them.
                    session.Update(persons[x]);
                }

                //And then commit the transaction if it all went well.
                transaction.Commit();
            }
        }

        /// <summary>
        /// WARNING!  THIS METHOD IS EXPOSED TO THE CLIENT AND IS NOT INTENDED FOR INTERNAL USE.  AUTHENTICATION, AUTHORIZATION AND VALIDATION MUST BE HANDLED PRIOR TO DB INTERACTION.
        /// <para />
        /// Loads the current day's muster and returns to the client the current day and year, the roll over hours we used to determine the muster and all persons the client is allowed to muster.
        /// <para />
        /// Client Parameters: <para />
        ///     None
        /// </summary>
        /// <param name="token"></param>
        /// <returns></returns>
        [EndpointMethod(EndpointName = "LoadMusterablePersonsForToday", AllowArgumentLogging = true, AllowResponseLogging = true, RequiresAuthentication = true)]
        private static void EndpointMethod_LoadTodaysMuster(MessageToken token)
        {
            if (token.AuthenticationSession == null)
            {
                token.AddErrorMessage("You must be logged in to view muster records.", ErrorTypes.Authentication, System.Net.HttpStatusCode.Unauthorized);
                return;
            }

            //Where we're going to keep all the persons the client can muster.
            List<Person> musterablePersons = new List<Person>();

            var resolvedPermissions = token.AuthenticationSession.Person.PermissionGroups.Resolve(token.AuthenticationSession.Person, null);
            var highestLevelInMuster = resolvedPermissions.HighestLevels["Muster"];

            using (var session = DataAccess.NHibernateHelper.CreateStatefulSession())
            {

                //Hold off on submitting the query for now because we need to know who we're looking for. People in the person's command, department or division.
                var queryOver = session.QueryOver<Person>();

                //Switch on the highest level in muster and then add the query accordingly.
                switch (highestLevelInMuster)
                {
                    case Authorization.Groups.PermissionGroupLevels.Command:
                        {
                            queryOver = queryOver.Where(x => x.Command == token.AuthenticationSession.Person.Command);
                            musterablePersons = queryOver.List().ToList();
                            break;
                        }
                    case Authorization.Groups.PermissionGroupLevels.Department:
                        {
                            queryOver = queryOver.Where(x => x.Department == token.AuthenticationSession.Person.Department);
                            musterablePersons = queryOver.List().ToList();
                            break;
                        }
                    case Authorization.Groups.PermissionGroupLevels.Division:
                        {
                            queryOver = queryOver.Where(x => x.Division == token.AuthenticationSession.Person.Division);
                            musterablePersons = queryOver.List().ToList();
                            break;
                        }
                    case Authorization.Groups.PermissionGroupLevels.Self:
                        {
                            //If the client's highest level is 'Self' then they can only muster themselves.
                            musterablePersons.Add(token.AuthenticationSession.Person);
                            break;
                        }
                    case Authorization.Groups.PermissionGroupLevels.None:
                        {
                            //If the client's highest level is none, then they basically got their permissions taken away.
                            break;
                        }
                    default:
                        {
                            throw new Exception("The default case in the highest level switch in the LoadMusterablePersonForToday endpoint was reached with the following case: '{0}'!".FormatS(highestLevelInMuster));
                        }
                }

                //Now that we have the results from the database, let's project them into our results.  This won't be the final DTO, we're going to layer on some additional information for the client to use.
                //Because Atwood is a good code monkey. Oh yes he is.
                var results = musterablePersons.Select(x =>
                {
                    return new
                    {
                        Id = x.Id,
                        FirstName = x.FirstName,
                        MiddleName = x.MiddleName,
                        LastName = x.LastName,
                        Paygrade = x.Paygrade,
                        Designation = x.Designation == null ? "" : x.Designation.Value, //Designation can be null.
                        Division = x.Division.Value,
                        Department = x.Department.Value,
                        Command = x.Command.Value,
                        UIC = x.UIC == null ? "" : x.UIC.Value, //UIC can also be null.
                        FriendlyName = x.ToString(),
                        CurrentMusterStatus = new
                        {
                            x.CurrentMusterStatus.Command,
                            x.CurrentMusterStatus.Department,
                            x.CurrentMusterStatus.Division,
                            x.CurrentMusterStatus.DutyStatus,
                            x.CurrentMusterStatus.HasBeenSubmitted,
                            x.CurrentMusterStatus.Id,
                            x.CurrentMusterStatus.MusterDayOfYear,
                            Musteree = x.CurrentMusterStatus.Musteree.ToBasicPerson(),
                            Musterer = x.CurrentMusterStatus.Musterer == null ? null : x.CurrentMusterStatus.Musterer.ToBasicPerson(),
                            x.CurrentMusterStatus.MusterStatus,
                            x.CurrentMusterStatus.MusterYear,
                            x.CurrentMusterStatus.Paygrade,
                            x.CurrentMusterStatus.SubmitTime,
                            x.CurrentMusterStatus.UIC
                        },
                        CanMuster = CanClientMusterPerson(token.AuthenticationSession.Person, x),
                        HasBeenMustered = x.CurrentMusterStatus.HasBeenSubmitted
                    };
                });

                //And now build the final DTO that's going out the door.
                token.SetResult(new
                {
                    CurrentYear = GetMusterYear(token.CallTime),
                    CurrentDay = GetMusterDay(token.CallTime),
                    Musters = results,
                    RolloverTime = _rolloverTime.ToString(),
                    ExpectedCompletionTime = _dueTime.ToString()
                });
            }
        }

        /// <summary>
        /// WARNING!  THIS METHOD IS EXPOSED TO THE CLIENT AND IS NOT INTENDED FOR INTERNAL USE.  AUTHENTICATION, AUTHORIZATION AND VALIDATION MUST BE HANDLED PRIOR TO DB INTERACTION.
        /// <para />
        /// Finalized the current muster, which sets a flag and prevents all any more muster submissions.
        /// <para />
        /// Client Parameters: <para />
        ///     None
        /// </summary>
        /// <param name="token"></param>
        /// <returns></returns>
        [EndpointMethod(EndpointName = "FinalizeMuster", AllowResponseLogging = true, AllowArgumentLogging = true, RequiresAuthentication = true)]
        private static void EndpointMethod_FinalizeMuster(MessageToken token)
        {
            //Let's make sure we have permission to finalize muster.  You can finalize muster if you're logged in (no shit) and a command level muster... person.
            if (token.AuthenticationSession == null)
            {
                token.AddErrorMessage("You must be logged in to finalize the muster.", ErrorTypes.Authentication, System.Net.HttpStatusCode.Unauthorized);
                return;
            }

            if (!token.AuthenticationSession.Person.PermissionGroups.CanAccessSubmodules(SubModules.AdminTools.ToString()))
            {
                token.AddErrorMessage("You are not authorized to finalize muster.", ErrorTypes.Authorization, System.Net.HttpStatusCode.Unauthorized);
                return;
            }

            //Ok we have permission, let's make sure the muster hasn't already been finalized.
            if (IsMusterFinalized)
            {
                token.AddErrorMessage("The muster has already been finalized.", ErrorTypes.Validation, System.Net.HttpStatusCode.BadRequest);
                return;
            }

            //So we should be good to finalize the muster.
            FinalizeMuster(token.AuthenticationSession.Person);
        }

        #endregion

        #region Startup Methods

        /// <summary>
        /// Registers the roll over method to run at a certain time.
        /// </summary>
        [ServiceManagement.StartMethod(Priority = 1)]
        private static void SetupMuster()
        {
            Communicator.PostMessage("Detecting current muster state...", Communicator.MessageTypes.Informational);


            using (var session = DataAccess.NHibernateHelper.CreateStatefulSession())
            using (var transaction = session.BeginTransaction())
            {
                try
                {
                    var persons = GetMusterablePersons();

                    if (persons.Select(x => x.CurrentMusterStatus).GroupBy(x => x.MusterDayOfYear).Count() != 1)
                    {
                        Communicator.PostMessage("Current muster records are not all for the same day!  Cleaning up muster records...", Communicator.MessageTypes.Warning);

                        //Ok so these muster records aren't all from the same day.
                        //To fix this we're going to select any muster records that's aren't for today and then try to archive them and the reset the person's profile with a blank muster record.
                        //During the archive, we'll need to ask if the person already has a muster record for that day, if so, we'll throw out the one we have.
                        var recordsInError = persons.Select(x => x.CurrentMusterStatus).Where(x => x.MusterDayOfYear != GetMusterDay(DateTime.Now) && x.MusterYear != GetMusterYear(DateTime.Now));

                        List<MusterRecord> musterRecordsForReset = new List<MusterRecord>();

                        List<Person> personsNeedingNewMusterRecords = new List<Person>();

                        //Ok we have them, now see if they already exist for the user.
                        foreach (var record in recordsInError)
                        {
                            //Query for this date and year for this person.
                            var otherRecordsFromSameDay = session.QueryOver<MusterRecord>()
                                .Where(x => x.MusterDayOfYear == record.MusterDayOfYear && x.MusterYear == record.MusterYear && x.Musteree.Id == record.Musteree.Id && x.Id != record.Id)
                                .List();

                            if (otherRecordsFromSameDay.Count != 0)
                            {
                                //There's already a record in the archive, so let's add this one to the list of muster records to be reset.
                                musterRecordsForReset.Add(record);

                                Communicator.PostMessage("A current muster record for the person, '{0}', was found for the day and year, '{1}':'{2}'.".FormatS(record.Musteree.ToString(), record.MusterDayOfYear, record.MusterYear) +
                                    "  While trying to archive that record, another record for that date was found to have already been archived.  The current muster record in question was thrown out.", Communicator.MessageTypes.Warning);
                            }
                            else //There is no archive yet, so we'll add it.  We "add" it by just resetting the muster record on the profile entirely.
                            {
                                personsNeedingNewMusterRecords.Add(record.Musteree);

                                Communicator.PostMessage("A muster record for the person, '{0}', was found for the day and year, '{1}':'{2}'.".FormatS(record.Musteree.ToString(), record.MusterDayOfYear, record.MusterYear) +
                                    "  The record has been archived and the person's current muster record was reset.", Communicator.MessageTypes.Warning);
                            }
                        }

                        //Let's handle the stuff we got and do the updates..  This first one, we need to reset without changing the reference.
                        for (int x = 0; x < musterRecordsForReset.Count; x++)
                        {
                            musterRecordsForReset[x].Command = null;
                            musterRecordsForReset[x].Department = null;
                            musterRecordsForReset[x].Division = null;
                            musterRecordsForReset[x].DutyStatus = null;
                            musterRecordsForReset[x].HasBeenSubmitted = false;
                            musterRecordsForReset[x].MusterDayOfYear = GetMusterDay(DateTime.Now);
                            musterRecordsForReset[x].Musterer = null;
                            musterRecordsForReset[x].MusterStatus = null;
                            musterRecordsForReset[x].MusterYear = GetMusterYear(DateTime.Now);
                            musterRecordsForReset[x].Paygrade = null;
                            musterRecordsForReset[x].SubmitTime = default(DateTime);
                            musterRecordsForReset[x].UIC = null;

                            session.Update(musterRecordsForReset[x]);
                        }

                        //This one though, the person legit needs a whoel new muster record.
                        foreach (var person in personsNeedingNewMusterRecords)
                        {
                            person.CurrentMusterStatus = CreateDefaultMusterRecordForPerson(person, DateTime.Now);

                            session.Update(person);
                        }

                        Communicator.PostMessage("Muster record clean up completed.", Communicator.MessageTypes.Warning);

                    }

                    //Ok, at this point, we know that we have muster records for today.  Let's just tell the host how far along we are.
                    Communicator.PostMessage("{0}/{1} person(s) have been mustered so far.".FormatS(persons.Count(x => x.CurrentMusterStatus.HasBeenSubmitted), persons.Count), Communicator.MessageTypes.Informational);
                    Communicator.PostMessage("Muster finalization status : {0}".FormatS(IsMusterFinalized ? "Finalized" : "Not Finalized" ), Communicator.MessageTypes.Informational);
                    Communicator.PostMessage("Expected completion time : {0}".FormatS(_dueTime.ToString()), Communicator.MessageTypes.Informational);
                    Communicator.PostMessage("Rollover time : {0}".FormatS(_rolloverTime.ToString()), Communicator.MessageTypes.Informational);

                    Communicator.PostMessage("Registering muster roll over to occur every day at '{0}'".FormatS(_rolloverTime.ToString()), Communicator.MessageTypes.Informational);
                    FluentScheduler.JobManager.AddJob(RolloverMuster, s => s.ToRunEvery(1).Days().At(_rolloverTime.Hours, _rolloverTime.Minutes));


                    transaction.Commit();
                }
                catch
                {
                    transaction.Rollback();
                    throw;
                }
            }
        }

        #endregion

        /// <summary>
        /// Maps a record to the database.
        /// </summary>
        public class MusterRecordMapping : ClassMap<MusterRecord>
        {
            /// <summary>
            /// Maps a record to the database.
            /// </summary>
            public MusterRecordMapping()
            {
                Id(x => x.Id).GeneratedBy.Assigned();

                References(x => x.Musterer).Nullable().LazyLoad(Laziness.False);
                References(x => x.Musteree).Nullable().LazyLoad(Laziness.False);

                Map(x => x.Paygrade).Nullable().Length(40);
                Map(x => x.Division).Nullable().Length(40);
                Map(x => x.Department).Nullable().Length(40);
                Map(x => x.Command).Nullable().Length(40);
                Map(x => x.MusterStatus).Nullable().Length(40);
                Map(x => x.DutyStatus).Nullable().Length(40);
                Map(x => x.SubmitTime).Nullable();
                Map(x => x.MusterDayOfYear).Nullable();
                Map(x => x.MusterYear).Not.Nullable();
                Map(x => x.HasBeenSubmitted).Nullable();
            }
        }

    }
}
