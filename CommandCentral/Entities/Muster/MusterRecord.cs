using System;
using System.Collections.Generic;
using CommandCentral.ClientAccess;
using FluentNHibernate.Mapping;
using AtwoodUtils;
using System.Linq;
using NHibernate.Criterion;

namespace CommandCentral.Entities.Muster
{
    /// <summary>
    /// Describes a single muster record, intended to archive the fact that a person claimed that another person was in a given state at a given time.
    /// </summary>
    public class MusterRecord
    {

        /// <summary>
        /// The hour at which the muster will roll over, starting a new muster day, regardless of the current muster's status.
        /// </summary>
        private static readonly Time _rolloverTime = new Time(16, 0, 0);

        /// <summary>
        /// The hour at which the muster _should_ be completed.  This governs when email are sent and their urgency.
        /// </summary>
        private static readonly Time _dueTime = new Time(9, 30, 0);

        /// <summary>
        /// Tracks whether or not the muster has been finalized.  If it has been, no more muster records should be accepted.
        /// <para />
        /// This is used in situations where a client forces the muster to finalize prior to its rollover time.
        /// </summary>
        public static bool IsMusterFinalized { get; private set; }

        #region Properties

        /// <summary>
        /// Unique GUID of this muster record
        /// </summary>
        public virtual Guid Id { get; set; }

        /// <summary>
        /// Musterer - I hate that word
        /// </summary>
        public virtual Person Musterer { get; set; }

        /// <summary>
        /// The Person being mustered by the musterer, which is the person mustering the person that must be mustered. muster.
        /// </summary>
        public virtual Person Musteree { get; set; }

        /// <summary>
        /// The Person being mustered's paygrade. Fucking Mustard.
        /// </summary>
        public virtual string Paygrade { get; set; }

        /// <summary>
        /// The person being mustered's UIC.  Fucking Mustard x 2.
        /// </summary>
        public virtual string UIC { get; set; }

        /// <summary>
        /// The person that is having the muster happen to them's division.
        /// </summary>
        public virtual string Division { get; set; }

        /// <summary>
        /// The individual that is being made accountable for through the process of mustering's department
        /// </summary>
        public virtual string Department { get; set; }

        /// <summary>
        /// The human being chosen to say their name out loud in front of their peers to make sure they are alive and where they should be at that specific time's Command
        /// </summary>
        public virtual string Command { get; set; }

        /// <summary>
        /// The one tiny human being on this planet out of all the other people that signed a contract that has binded him into a life of accountability's muster state.
        /// </summary>
        public virtual string MusterStatus { get; set; }

        /// <summary>
        /// That same person from above's duty status
        /// </summary>
        public virtual string DutyStatus { get; set; }

        /// <summary>
        /// The date and time the person was mustered at.
        /// </summary>
        public virtual DateTime SubmitTime { get; set; }

        /// <summary>
        /// The day of the year for which this muster was made.  Because the "muster day" may not align perfectly with a normal day, this value is tracked separately.
        /// </summary>
        public virtual int MusterDayOfYear { get; set; }

        /// <summary>
        /// The year this muster record is in.
        /// </summary>
        public virtual int MusterYear { get; set; }

        /// <summary>
        /// Indicates whether or not this record has been submitted yet or if it was auto generated by the application.
        /// </summary>
        public virtual bool HasBeenSubmitted { get; set; }

        #endregion

        #region Helper Methods

        /// <summary>
        /// Returns the muster day, which is the Julian date shifted by the offset given by the _rolloverHour variable.
        /// </summary>
        /// <param name="dateTime"></param>
        /// <returns></returns>
        public static int GetMusterDay(DateTime dateTime)
        {
            System.Globalization.JulianCalendar julCalendar = new System.Globalization.JulianCalendar();

            if (dateTime.InclusiveBetween(dateTime.Date.Subtract(TimeSpan.FromHours(24) - TimeSpan.FromSeconds(_rolloverTime.GetSeconds())), dateTime.Date.AddSeconds(_rolloverTime.GetSeconds())))
                return julCalendar.GetDayOfYear(dateTime);
            else
            {
                //If we're here then we're after the muster rollover hour.  For example, the roll over is 16 and we're on 17.  This means that the muster day is the NEXT day.
                //However, we need to make sure we don't return a date that is out of range for the year.  So if today is the last day of the year, then return 1, because we'll be starting next year's muster.
                if (julCalendar.GetDaysInYear(dateTime.Year) == julCalendar.GetDayOfYear(dateTime))
                    return 1;
                else
                    return julCalendar.GetDayOfYear(dateTime) + 1;
            }
        }

        /// <summary>
        /// Gets the current year of the muster.
        /// </summary>
        /// <param name="dateTime"></param>
        /// <returns></returns>
        public static int GetMusterYear(DateTime dateTime)
        {
            System.Globalization.JulianCalendar julCalendar = new System.Globalization.JulianCalendar();

            if (dateTime.InclusiveBetween(dateTime.Date.Subtract(TimeSpan.FromHours(24) - TimeSpan.FromSeconds(_rolloverTime.GetSeconds())), dateTime.Date.AddSeconds(_rolloverTime.GetSeconds())))
                return julCalendar.GetYear(dateTime);
            else
            {
                //If we're here then we're after the muster rollover hour.  For example, the roll over is 16 and we're on 17.  This means that the muster day is the NEXT day.
                //However, we need to make sure we don't return a date that is out of range for the year.  So if today is the last day of the year, then return 1, because we'll be starting next year's muster.
                if (julCalendar.GetDaysInYear(dateTime.Year) == julCalendar.GetDayOfYear(dateTime))
                    return julCalendar.GetYear(dateTime) + 1; //This makes the assumption that time is infinite.  This might require refactoring if proven otherwise.
                else
                    return julCalendar.GetYear(dateTime);
            }
        }

        /// <summary>
        /// Creates a new muster status with everything set to null except the musteree and the current day values.
        /// </summary>
        /// <param name="person"></param>
        /// <param name="date">The date time for which to create this muster record.</param>
        /// <returns></returns>
        public static MusterRecord CreateDefaultMusterRecordForPerson(Person person, DateTime date)
        {
            return new MusterRecord
            {
                Id = Guid.NewGuid(),
                Command = null,
                Department = null,
                Division = null,
                DutyStatus = null,
                MusterDayOfYear = GetMusterDay(date),
                Musteree = person,
                Musterer = null,
                MusterStatus = null,
                MusterYear = GetMusterYear(date),
                Paygrade = null,
                UIC = null,
                SubmitTime = default(DateTime)
            };
        }

        /// <summary>
        /// Returns a boolean indicating whether or not the given person (client) can muster the other given person (person).
        /// </summary>
        /// <param name="client"></param>
        /// <param name="person"></param>
        /// <returns></returns>
        public static bool CanClientMusterPerson(Person client, Person person)
        {
            //Clients are allowed to muster themselves.
            if (client.Id == person.Id)
                return true;

            //What is the highest permission level this person has.
            Authorization.PermissionLevels highestLevel = client.GetHighestLevelInTrack(Authorization.PermissionTracks.Muster);

            //If none, then return false;
            if (highestLevel == Authorization.PermissionLevels.None)
                return false;

            //Alright, now go through the CoC checks.
            if (highestLevel == Authorization.PermissionLevels.Command && client.IsInSameCommandAs(person))
                return true;
            if (highestLevel == Authorization.PermissionLevels.Department && client.IsInSameDepartmentAs(person))
                return true;
            if (highestLevel == Authorization.PermissionLevels.Division && client.IsInSameDivisionAs(person))
                return true;

            return false;
        }

        /// <summary>
        /// Finalizes the muster for the current day by taking all of the current muster records from all persons in the database, 
        /// using them to build a report, 
        /// sending an email report, 
        /// saving the report,
        /// and then resetting everyone's current muster record and then archiving the old ones.
        /// </summary>
        /// <param name="person">The person who initiated the muster finalization.  If null, the system initiated it.</param>
        public static void FinalizeMuster(Person person)
        {
            if (IsMusterFinalized)
                throw new Exception("You can't finalize the muster.  It's already been finalized.  A rollover must first occur.");

            //First up, we need everyone and their muster records.  Actually we need a session first.
            using (var session = DataAccess.NHibernateHelper.CreateStatefulSession())
            using (var transaction = session.BeginTransaction())
            {
                try
                {
                    var persons = session.QueryOver<Person>()
                                    .Fetch(x => x.CurrentMusterStatus).Eager
                                    .List();

                    //Ok we have all the persons and their muster records.  #thatwaseasy  Now we need to build a report of the current muster

                    //Build muster report using given information.
                    var musterReport = new MusterReport();

                    EmailHelper.SendMusterReportEmail(musterReport);

                    //Save the muster report.
                    //TODO save the muster report.

                    //Now we just need to shut out the muster such that it can't be used until the roll over happens.

                    IsMusterFinalized = true;
                }
                catch (Exception e)
                {
                    transaction.Rollback();
                    Communicator.PostMessageToHost("The rollover muster method failed!  All changes were rolled back. The muster was not advanced! Error message: {0}".FormatS(e.Message), Communicator.MessageTypes.Critical);

                    EmailHelper.SendFatalErrorEmail(null, e);

                    session.Save(new Error(e, DateTime.Now, null));

                    //Note: we can't rethrow the error because no one is listening for it.  We just need to handle that here.  We're far outside the sync context, just south of the rishi maze.
                }
            }
        }

        /// <summary>
        /// Rolls over the muster.
        /// </summary>
        public static void RolloverMuster()
        {

        }

        /// <summary>
        /// Returns a list of those persons who are currently musterable.  Uses a given session to do the loading.
        /// </summary>
        /// <param name="session"></param>
        /// <returns></returns>
        public static IList<Person> GetMusterablePersons(NHibernate.ISession session)
        {
            return session.QueryOver<Person>().Where(x => x.DutyStatus != DutyStatuses.Loss).List();
        }

        /// <summary>
        /// Returns a list of those persons who are currently musterable.  Uses a new session to do the loading then disposes it.
        /// </summary>
        /// <param name="session"></param>
        /// <returns></returns>
        public static IList<Person> GetMusterablePersons()
        {

            using (var session = DataAccess.NHibernateHelper.CreateStatefulSession())
            {
                return session.QueryOver<Person>().Where(x => x.DutyStatus != DutyStatuses.Loss).List();
            }
        }

        #endregion

        #region Client Access

        /// <summary>
        /// WARNING!  THIS METHOD IS EXPOSED TO THE CLIENT AND IS NOT INTENDED FOR INTERNAL USE.  AUTHENTICATION, AUTHORIZATION AND VALIDATION MUST BE HANDLED PRIOR TO DB INTERACTION.
        /// <para />
        /// Loads a muster record for a given id and returns null if none exists.
        /// <para />
        /// Client Parameters: <para />
        ///     musterrecordid - the Id of the muster record we want to load.
        /// </summary>
        /// <param name="token"></param>
        /// <returns></returns>
        [EndpointMethod(EndpointName = "LoadMusterRecord", AllowArgumentLogging = true, AllowResponseLogging = true, RequiresAuthentication = true)]
        private static void EndpointMethod_LoadMusterRecord(MessageToken token)
        {
            if (token.AuthenticationSession == null)
            {
                token.AddErrorMessage("You must be logged in to view muster records.", ErrorTypes.Authentication, System.Net.HttpStatusCode.Unauthorized);
                return;
            }

            if (!token.Args.ContainsKey("musterrecordid"))
            {
                token.AddErrorMessage("You must send a 'musterrecordid' parameter.", ErrorTypes.Validation, System.Net.HttpStatusCode.BadRequest);
                return;
            }

            Guid musterRecordId;
            if (!Guid.TryParse(token.Args["musterrecordid"] as string, out musterRecordId))
            {
                token.AddErrorMessage("Your muster record id was not legitsky.", ErrorTypes.Validation, System.Net.HttpStatusCode.BadRequest);
                return;
            }

            using (var session = DataAccess.NHibernateHelper.CreateStatefulSession())
            {
                token.SetResult(session.Get<MusterRecord>(musterRecordId));
            }
        }

        /// <summary>
        /// WARNING!  THIS METHOD IS EXPOSED TO THE CLIENT AND IS NOT INTENDED FOR INTERNAL USE.  AUTHENTICATION, AUTHORIZATION AND VALIDATION MUST BE HANDLED PRIOR TO DB INTERACTION.
        /// <para />
        /// Loads all muster records for a given person in which the person was the Musteree - the one being le mustered.  
        /// <para />
        /// Client Parameters: <para />
        ///     mustereeId - the Id of the person for whom to load muster records where the person is the one being mustered.
        /// </summary>
        /// <param name="token"></param>
        /// <returns></returns>
        [EndpointMethod(EndpointName = "LoadMusterRecordsByMusteree", AllowArgumentLogging = true, AllowResponseLogging = true, RequiresAuthentication = true)]
        private static void EndpointMethod_LoadMusterRecordsByMusteree(MessageToken token)
        {
            if (token.AuthenticationSession == null)
            {
                token.AddErrorMessage("You must be logged in to view muster records.", ErrorTypes.Authentication, System.Net.HttpStatusCode.Unauthorized);
                return;
            }

            if (!token.Args.ContainsKey("mustereeid"))
            {
                token.AddErrorMessage("You must send a 'mustereeid' parameter.", ErrorTypes.Validation, System.Net.HttpStatusCode.BadRequest);
                return;
            }

            Guid mustereeId;
            if (!Guid.TryParse(token.Args["mustereeid"] as string, out mustereeId))
            {
                token.AddErrorMessage("Your 'mustereeid' parameter was not in a valid format.", ErrorTypes.Validation, System.Net.HttpStatusCode.BadRequest);
                return;
            }

            using (var session = DataAccess.NHibernateHelper.CreateStatefulSession())
            {
                //Set the result.
                token.SetResult(session.QueryOver<MusterRecord>().Where(x => x.Musteree.Id == mustereeId));
            }
        }

        /// <summary>
        /// WARNING!  THIS METHOD IS EXPOSED TO THE CLIENT AND IS NOT INTENDED FOR INTERNAL USE.  AUTHENTICATION, AUTHORIZATION AND VALIDATION MUST BE HANDLED PRIOR TO DB INTERACTION.
        /// <para />
        /// Loads all muster records for a given person in which the person was the Musterer - the one doing le mustering.  
        /// <para />
        /// Client Parameters: <para />
        ///     mustererId - the Id of the person for whom to load muster records where the person is the one doing the mustering.
        /// </summary>
        /// <param name="token"></param>
        /// <returns></returns>
        [EndpointMethod(EndpointName = "LoadMusterRecordsByMusterer", AllowArgumentLogging = true, AllowResponseLogging = true, RequiresAuthentication = true)]
        private static void EndpointMethod_LoadMusterRecordsByMusterer(MessageToken token)
        {
            if (token.AuthenticationSession == null)
            {
                token.AddErrorMessage("You must be logged in to view muster records.", ErrorTypes.Authentication, System.Net.HttpStatusCode.Unauthorized);
                return;
            }

            if (!token.Args.ContainsKey("mustererid"))
            {
                token.AddErrorMessage("You must send a 'mustererid' parameter.", ErrorTypes.Validation, System.Net.HttpStatusCode.BadRequest);
                return;
            }

            Guid mustererId;
            if (!Guid.TryParse(token.Args["mustererid"] as string, out mustererId))
            {
                token.AddErrorMessage("Your 'mustererid' parameter was not in a valid format.", ErrorTypes.Validation, System.Net.HttpStatusCode.BadRequest);
                return;
            }

            using (var session = DataAccess.NHibernateHelper.CreateStatefulSession())
            {
                //Set the result.
                token.SetResult(session.QueryOver<MusterRecord>().Where(x => x.Musterer.Id == mustererId));
            }
        }

        /// <summary>
        /// WARNING!  THIS METHOD IS EXPOSED TO THE CLIENT AND IS NOT INTENDED FOR INTERNAL USE.  AUTHENTICATION, AUTHORIZATION AND VALIDATION MUST BE HANDLED PRIOR TO DB INTERACTION.
        /// <para />
        /// Loads all muster records for a given muster date. This will be converted to a muster date based on the rollover time shift.  Recommend that you submit the date time without a time portion or with the time portion set to midnight - although it doesn't matter.
        /// <para />
        /// Client Parameters: <para />
        ///     musterdate - The date for which to load muster records. Keep in mind, asking for muster records for a time after the roll over time will in fact return the next day's muster records.  This is due to the rollover time shift.
        /// </summary>
        /// <param name="token"></param>
        /// <returns></returns>
        [EndpointMethod(EndpointName = "LoadMusterRecordsByMusterDay", AllowArgumentLogging = true, AllowResponseLogging = true, RequiresAuthentication = true)]
        private static void EndpointMethod_LoadMusterRecordsByMusterDay(MessageToken token)
        {
            if (token.AuthenticationSession == null)
            {
                token.AddErrorMessage("You must be logged in to view muster records.", ErrorTypes.Authentication, System.Net.HttpStatusCode.Unauthorized);
                return;
            }

            if (!token.Args.ContainsKey("musterdate"))
            {
                token.AddErrorMessage("You must send a 'musterdate' parameter.", ErrorTypes.Validation, System.Net.HttpStatusCode.BadRequest);
                return;
            }

            DateTime musterDate;
            if (!DateTime.TryParse(token.Args["musterdate"] as string, out musterDate))
            {
                token.AddErrorMessage("Your 'musterdate' parameter was not in a valid format.", ErrorTypes.Validation, System.Net.HttpStatusCode.BadRequest);
                return;
            }

            using (var session = DataAccess.NHibernateHelper.CreateStatefulSession())
            {
                //Get all records where the day of the year is the given day's muster day and the year the same.
                token.SetResult(session.QueryOver<MusterRecord>().Where(x => x.MusterDayOfYear == MusterRecord.GetMusterDay(musterDate) && x.MusterYear == musterDate.Year).List());
            }
        }

        /// <summary>
        /// WARNING!  THIS METHOD IS EXPOSED TO THE CLIENT AND IS NOT INTENDED FOR INTERNAL USE.  AUTHENTICATION, AUTHORIZATION AND VALIDATION MUST BE HANDLED PRIOR TO DB INTERACTION.
        /// <para />
        /// Given a dictionary of personIds/MusterStatuses, attempts to submit muster for all persons, failing if a person doesn't exist for the given Id, or if the client can't submit muster for any one of the persons.  If a person has already been mustered for this day, that person is not re-mustered.  All persons who were mustered, their Ids will be returned.
        /// <para />
        /// Options: <para />
        ///     mustersubmissions - A dictionary where the key is the person's Id, and the value is the MusterStatus to assign to this person.  The muster status should be a full muster status object.
        /// </summary>
        /// <param name="token"></param>
        /// <returns></returns>
        [EndpointMethod(EndpointName = "SubmitMuster", AllowArgumentLogging = true, AllowResponseLogging = true, RequiresAuthentication = true)]
        private static void EndpointMethod_SubmitMuster(MessageToken token)
        {
            if (token.AuthenticationSession == null)
            {
                token.AddErrorMessage("You must be logged in to submit muster records.", ErrorTypes.Authentication, System.Net.HttpStatusCode.Unauthorized);
                return;
            }

            //Before we do anything, make sure the client has permission to do muster.  As long as they are in a permission group in the Muster track, that'll be enough.
            if (!token.AuthenticationSession.Person.IsInPermissionTrack(Authorization.PermissionTracks.Muster))
            {
                token.AddErrorMessage("You are not authorized to submit muster.", ErrorTypes.Authorization, System.Net.HttpStatusCode.Unauthorized);
                return;
            }

            //Did we get what we needed?
            if (!token.Args.ContainsKey("mustersubmissions"))
            {
                token.AddErrorMessage("You must send a 'mustersubmissions' parameter.", ErrorTypes.Validation, System.Net.HttpStatusCode.BadRequest);
                return;
            }


            Dictionary<Guid, string> musterSubmissions = null;
            //When we try to parse the JSON from the request, we'll do it in a try catch because there's no convenient, performant TryParse implementation for this.
            try
            {
                musterSubmissions = token.Args["mustersubmissions"].CastJToken<Dictionary<Guid, string>>();
            }
            catch (Exception e)
            {
                token.AddErrorMessage("There was an error while trying to format your 'mustersubmissions' argument.  It should be sent in a JSON dictionary.  Parsing error details: {0}".FormatS(e.Message), ErrorTypes.Validation, System.Net.HttpStatusCode.BadRequest);
                return;
            }

            //Validate the muster statuses
            MusterStatuses tempStatus;
            if (musterSubmissions.Values.Any(x => !Enum.TryParse<MusterStatuses>(x, out tempStatus)))
            {
                token.AddErrorMessage("One or more requested muster statuses were not valid.", ErrorTypes.Validation, System.Net.HttpStatusCode.BadRequest);
                return;
            }

            //This is the session in which we're going to do our muster updates.  We do it separately in case something terrible happens to the currently logged in user.
            //This means that if the currently logged in person updates their own muster then for the rest of this request, their muster will be invalid.  That's ok cause we shouldn't need it.
            using (var session = DataAccess.NHibernateHelper.CreateStatefulSession())
            using (var transaction = session.BeginTransaction())
            {
                //Tell the session we'll handle commits through the transaction, otherwise every property update on the current muster status will result in an update.
                session.CacheMode = NHibernate.CacheMode.Ignore;
                session.FlushMode = NHibernate.FlushMode.Commit;

                //Submit the query to load all the persons.  How fucking easy can this be.  Fuck off NHibernate.  Fetch the command/dep/div so we can use it without lazy loading.
                var persons = session.QueryOver<Person>().AndRestrictionOn(x => x.Id).IsIn(musterSubmissions.Keys)
                    .Fetch(x => x.Department).Eager
                    .Fetch(x => x.Command).Eager
                    .Fetch(x => x.Division).Eager
                    .List();

                //Now we need to make sure the client is allowed to muster the persons the client wants to muster.
                if (persons.Any(x => !CanClientMusterPerson(token.AuthenticationSession.Person, x)))
                {
                    token.AddErrorMessage("You were not authorized to muster one or more of the persons you tried to muster.", ErrorTypes.Authorization, System.Net.HttpStatusCode.Unauthorized);
                    return;
                }

                //Ok, the client is allowed to muster them.  Now we need to set their current muster statuses.
                for (int x = 0; x < persons.Count; x++)
                {
                    persons[x].CurrentMusterStatus.HasBeenSubmitted = true;
                    persons[x].CurrentMusterStatus.MusterDayOfYear = GetMusterDay(token.CallTime);
                    persons[x].CurrentMusterStatus.Musterer = token.AuthenticationSession.Person;
                    persons[x].CurrentMusterStatus.MusterStatus = musterSubmissions.ElementAt(x).Value;
                    persons[x].CurrentMusterStatus.MusterYear = GetMusterYear(token.CallTime);
                    persons[x].CurrentMusterStatus.SubmitTime = token.CallTime;

                    //And once we're done resetting their current muster status, let's update them.
                    session.Update(persons[x]);
                }

                //And then commit the transaction if it all went well.
                transaction.Commit();
            }

            //Ok, well we're done!  Now we just need to tell the client that we finished and tell the client for whom we submitted muster records.  Because why not.
            token.SetResult(musterSubmissions.Select(x => x.Key.ToString()).ToList());
        }

        /// <summary>
        /// WARNING!  THIS METHOD IS EXPOSED TO THE CLIENT AND IS NOT INTENDED FOR INTERNAL USE.  AUTHENTICATION, AUTHORIZATION AND VALIDATION MUST BE HANDLED PRIOR TO DB INTERACTION.
        /// <para />
        /// Loads the current day's muster and returns to the client the current day and year, the roll over hours we used to determine the muster and all persons the client is allowed to muster.
        /// <para />
        /// Client Parameters: <para />
        ///     None
        /// </summary>
        /// <param name="token"></param>
        /// <returns></returns>
        [EndpointMethod(EndpointName = "LoadTodaysMuster", AllowArgumentLogging = true, AllowResponseLogging = true, RequiresAuthentication = true)]
        private static void EndpointMethod_LoadTodaysMuster(MessageToken token)
        {
            if (token.AuthenticationSession == null)
            {
                token.AddErrorMessage("You must be logged in to view muster records.", ErrorTypes.Authentication, System.Net.HttpStatusCode.Unauthorized);
                return;
            }

            //Where we're going to keep all the persons the client can muster.
            List<Person> musterablePersons = new List<Person>();

            Authorization.PermissionLevels highestLevel = token.AuthenticationSession.Person.GetHighestLevelInTrack(Authorization.PermissionTracks.Muster);

            using (var session = DataAccess.NHibernateHelper.CreateStatefulSession())
            {
                //If they aren't in the muster track, they can at least muster themselves, else we need a query to find out everyone else they can muster.
                if (highestLevel == Authorization.PermissionLevels.None)
                {
                    musterablePersons.Add(token.AuthenticationSession.Person);
                }
                else
                {
                    //We need all the current muster records for today.  Make sure to fetch any references we might need so we don't wind up with some select n+1 shit.
                    //Hold off on submitting the query for now because we need to know who we're looking for. People in the person's command, department or division.
                    var queryOver = session.QueryOver<Person>();

                    switch (highestLevel)
                    {
                        case Authorization.PermissionLevels.Command:
                            {
                                queryOver = queryOver.Where(x => x.Command == token.AuthenticationSession.Person.Command);
                                break;
                            }
                        case Authorization.PermissionLevels.Department:
                            {
                                queryOver = queryOver.Where(x => x.Department == token.AuthenticationSession.Person.Department);
                                break;
                            }
                        case Authorization.PermissionLevels.Division:
                            {
                                queryOver = queryOver.Where(x => x.Division == token.AuthenticationSession.Person.Division);
                                break;
                            }
                        default:
                            {
                                throw new Exception("The default case in the high level switch in the LoadTodaysMuster was reached with the following case: '{0}'!".FormatS(highestLevel));
                            }
                    }

                    //Now we have the query populated with the conditions it needs, let's fire it off.
                    musterablePersons = queryOver.List().ToList();
                }

                //Now that we have the results from the database, let's project them into our results.  This won't be the final DTO, we're going to layer on some additional information for the client to use.
                //Because Atwood is a good code monkey. Oh yes he is.
                var results = musterablePersons.Select(x =>
                {
                    return new
                    {
                        Id = x.Id,
                        FirstName = x.FirstName,
                        MiddleName = x.MiddleName,
                        LastName = x.LastName,
                        Paygrade = x.Paygrade,
                        Designation = x.Designation.Value,
                        Division = x.Division.Value,
                        Department = x.Department.Value,
                        Command = x.Command.Value,
                        UIC = x.UIC.Value,
                        FriendlyName = x.ToString(),
                        CurrentMusterStatus = x.CurrentMusterStatus,
                        CanMuster = CanClientMusterPerson(token.AuthenticationSession.Person, x),
                        HasBeenMustered = x.CurrentMusterStatus.HasBeenSubmitted
                    };
                });

                //And now build the final DTO that's going out the door.
                token.SetResult(new
                {
                    CurrentYear = GetMusterYear(token.CallTime),
                    CurrentDay = GetMusterDay(token.CallTime),
                    Musters = results,
                    RolloverTime = _rolloverTime.ToString(),
                    ExpectedCompletionTime = _dueTime.ToString()
                });
            }
        }

        [EndpointMethod(EndpointName = "FinalizeMuster", AllowResponseLogging = true, AllowArgumentLogging = true, RequiresAuthentication = true)]
        private static void EndpointMethod_FinalizeMuster(MessageToken token)
        {
            //Let's make sure we have permission to finalize muster.  You can finalize muster if you're logged in (no shit) and a command level muster... person.
            if (token.AuthenticationSession == null)
            {
                token.AddErrorMessage("You must be logged in to finalize the muster.", ErrorTypes.Authentication, System.Net.HttpStatusCode.Unauthorized);
                return;
            }

            if (!token.AuthenticationSession.Person.HasPermissionLevelInTrack(Authorization.PermissionLevels.Command, Authorization.PermissionTracks.Muster))
            {
                token.AddErrorMessage("You are not authorized to finalize muster.", ErrorTypes.Authorization, System.Net.HttpStatusCode.Unauthorized);
                return;
            }

            //Ok we have permission, let's make sure the muster hasn't already been finalized.
            if (IsMusterFinalized)
            {
                token.AddErrorMessage("The muster has already been finalized.", ErrorTypes.Validation, System.Net.HttpStatusCode.BadRequest);
                return;
            }

            //So we should be good to finalize the muster.
            FinalizeMuster(token.AuthenticationSession.Person);


        }

        #endregion

        #region Startup Methods

        [ServiceManagement.StartMethod(Priority = 1)]
        private static void RegisterRolloverMuster()
        {
            FluentScheduler.JobManager.AddJob(RolloverMuster, s => s.ToRunEvery(1).Days().At(_rolloverTime.Hours, _rolloverTime.Minutes));
        }

        #endregion

        /// <summary>
        /// Maps a record to the database.
        /// </summary>
        public class MusterRecordMapping : ClassMap<MusterRecord>
        {
            /// <summary>
            /// Maps a record to the database.
            /// </summary>
            public MusterRecordMapping()
            {
                Id(x => x.Id).GeneratedBy.Assigned();

                References(x => x.Musterer).Nullable();
                References(x => x.Musteree).Nullable();

                Map(x => x.Paygrade).Nullable().Length(10);
                Map(x => x.Division).Nullable().Length(10);
                Map(x => x.Department).Nullable().Length(10);
                Map(x => x.Command).Nullable().Length(10);
                Map(x => x.MusterStatus).Nullable().Length(20);
                Map(x => x.DutyStatus).Nullable().Length(20);
                Map(x => x.SubmitTime).Nullable();
                Map(x => x.MusterDayOfYear).Nullable();
                Map(x => x.MusterYear).Not.Nullable();
                Map(x => x.HasBeenSubmitted).Nullable();
            }
        }

    }
}
